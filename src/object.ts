import { isObject } from './typed'

// List of dangerous keys that could lead to prototype pollution
const DANGEROUS_KEYS = ['__proto__', 'constructor', 'prototype']

/**
 * Merges multiple objects deeply
 * @param target - The target object to merge into
 * @param sources - The source objects to merge from
 * @returns The merged object
 * @example
 * merge({ a: 1 }, { b: 2 }, { c: 3 }) // { a: 1, b: 2, c: 3 }
 * merge({ a: { x: 1 } }, { a: { y: 2 } }) // { a: { x: 1, y: 2 } }
 */
export const merge = <T extends Record<string, any>>(
  target: T,
  ...sources: any[]
): T => {
  if (!sources.length) return target
  const source = sources.shift()

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      // Security: Prevent prototype pollution
      if (DANGEROUS_KEYS.includes(key)) continue

      // Only process own properties
      if (!Object.prototype.hasOwnProperty.call(source, key)) continue

      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, { [key]: {} })
        merge(target[key], source[key])
      } else {
        Object.assign(target, { [key]: source[key] })
      }
    }
  }

  return sources.length > 0 ? merge(target, ...sources) : target
}

/**
 * Creates an object composed of the picked object properties
 * @param obj - The source object
 * @param keys - The property keys to pick
 * @returns New object with only the picked properties
 * @example
 * pick({ a: 1, b: 2, c: 3 }, ['a', 'c']) // { a: 1, c: 3 }
 */
export const pick = <T extends Record<string, any>, K extends keyof T>(
  obj: T,
  keys: K[]
): Pick<T, K> => {
  const result = {} as Pick<T, K>
  for (const key of keys) {
    if (key in obj) {
      result[key] = obj[key]
    }
  }
  return result
}

/**
 * Creates an object composed of the own and inherited enumerable property paths of object that are not omitted
 * @param obj - The source object
 * @param keys - The property keys to omit
 * @returns New object without the omitted properties
 * @example
 * omit({ a: 1, b: 2, c: 3 }, ['b']) // { a: 1, c: 3 }
 */
export const omit = <T extends Record<string, any>, K extends keyof T>(
  obj: T,
  keys: K[]
): Omit<T, K> => {
  const result = { ...obj } as Omit<T, K>
  for (const key of keys) {
    delete (result as any)[key]
  }
  return result
}

/**
 * Creates a deep clone of value
 * @param obj - The value to recursively clone
 * @returns Returns the deep cloned value
 * @example
 * const objects = [{ 'a': 1 }, { 'b': 2 }]
 * const deep = cloneDeep(objects)
 * console.log(deep[0] === objects[0]) // false
 */
export const cloneDeep = <T>(obj: T): T => {
  if (obj === null || typeof obj !== 'object') return obj
  if (obj instanceof Date) return new Date(obj.getTime()) as unknown as T
  if (obj instanceof RegExp)
    return new RegExp(obj.source, obj.flags) as unknown as T
  if (obj instanceof Array)
    return obj.map(item => cloneDeep(item)) as unknown as T
  if (typeof obj === 'object') {
    const clonedObj = {} as T
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        clonedObj[key] = cloneDeep(obj[key])
      }
    }
    return clonedObj
  }
  return obj
}

/**
 * Creates an object with the same values as object and keys generated by running each own enumerable string keyed property of object thru iteratee
 * @param obj - The object to invert
 * @returns Returns the new inverted object
 * @example
 * invert({ 'a': 1, 'b': 2, 'c': 1 }) // { '1': 'c', '2': 'b' }
 */
export const invert = <T extends Record<string, string | number>>(
  obj: T
): Record<string, string> => {
  const result: Record<string, string> = {}
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      result[String(obj[key])] = key
    }
  }
  return result
}
